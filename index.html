<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Twibbon ORIABA 2025</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f0f4f8;
    }
    h1 {
      margin-top: 20px;
    }
    #preview {
      margin: 20px auto;
      display: block;
      border: 2px solid #ccc;
      border-radius: 10px;
      touch-action: none; /* penting untuk pinch & drag di HP */
      cursor: grab;
    }
    .btn {
      margin: 10px;
      padding: 10px 20px;
      border: none;
      background: #2d6cdf;
      color: white;
      font-size: 16px;
      border-radius: 8px;
      cursor: pointer;
    }
    .btn:hover {
      background: #1a4eb8;
    }
  </style>
</head>
<body>

  <h1>Twibbon ORIABA 2025</h1>
  <p>Upload fotomu untuk dipasang ke Twibbon! (Bisa digeser & dizoom)</p>
  
  <input type="file" id="upload" accept="image/*" class="btn">
  <br>
  <canvas id="preview" width="800" height="1000"></canvas>
  <br>
  <button id="download" class="btn">Download Hasil</button>

  <script>
    const upload = document.getElementById('upload');
    const canvas = document.getElementById('preview');
    const ctx = canvas.getContext('2d');
    const twibbon = new Image();
    twibbon.src = "twibon.jpg"; // file twibbon

    let img = null;
    let imgX = 0, imgY = 0;
    let scale = 1;
    let isDragging = false;
    let startX, startY;

    function drawAll() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (img) {
        const w = img.width * scale;
        const h = img.height * scale;
        ctx.drawImage(img, imgX, imgY, w, h);
      }
      ctx.drawImage(twibbon, 0, 0, canvas.width, canvas.height);
    }

    upload.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(event) {
        img = new Image();
        img.onload = function() {
          scale = Math.max(canvas.width / img.width, canvas.height / img.height);
          imgX = (canvas.width - img.width * scale) / 2;
          imgY = (canvas.height - img.height * scale) / 2;
          drawAll();
        }
        img.src = event.target.result;
      }
      reader.readAsDataURL(file);
    });

    // --- Mouse Drag ---
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      startX = e.offsetX;
      startY = e.offsetY;
      canvas.style.cursor = "grabbing";
    });
    canvas.addEventListener('mouseup', () => {
      isDragging = false;
      canvas.style.cursor = "grab";
    });
    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
      canvas.style.cursor = "grab";
    });
    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging || !img) return;
      const dx = e.offsetX - startX;
      const dy = e.offsetY - startY;
      imgX += dx;
      imgY += dy;
      startX = e.offsetX;
      startY = e.offsetY;
      drawAll();
    });

    // --- Mouse Wheel Zoom ---
    canvas.addEventListener('wheel', (e) => {
      if (!img) return;
      e.preventDefault();
      const zoomAmount = e.deltaY * -0.001;
      const oldScale = scale;
      scale = Math.min(Math.max(0.1, scale + zoomAmount), 5);

      const mx = e.offsetX;
      const my = e.offsetY;
      imgX = mx - (mx - imgX) * (scale / oldScale);
      imgY = my - (my - imgY) * (scale / oldScale);

      drawAll();
    });

    // --- Touch Support (Drag & Pinch Zoom) ---
    let lastTouchDist = null;

    function getTouchDist(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx*dx + dy*dy);
    }

    canvas.addEventListener('touchstart', (e) => {
      if (!img) return;
      if (e.touches.length === 1) {
        // drag
        isDragging = true;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        // pinch
        lastTouchDist = getTouchDist(e.touches);
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      if (!img) return;
      e.preventDefault();
      if (e.touches.length === 1 && isDragging) {
        const dx = e.touches[0].clientX - startX;
        const dy = e.touches[0].clientY - startY;
        imgX += dx;
        imgY += dy;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        const newDist = getTouchDist(e.touches);
        if (lastTouchDist) {
          const zoomAmount = (newDist - lastTouchDist) * 0.005;
          const oldScale = scale;
          scale = Math.min(Math.max(0.1, scale + zoomAmount), 5);

          const rect = canvas.getBoundingClientRect();
          const mx = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
          const my = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;

          imgX = mx - (mx - imgX) * (scale / oldScale);
          imgY = my - (my - imgY) * (scale / oldScale);
        }
        lastTouchDist = newDist;
      }
      drawAll();
    });

    canvas.addEventListener('touchend', () => {
      isDragging = false;
      lastTouchDist = null;
    });

    // Download hasil
    document.getElementById('download').addEventListener('click', function() {
      const link = document.createElement('a');
      link.download = 'twibbon_oriaba2025.png';
      link.href = canvas.toDataURL("image/png");
      link.click();
    });
  </script>

</body>
</html>
